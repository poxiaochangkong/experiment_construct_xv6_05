需要新建的核心文件
kernel/trap.c


参考 xv6 的 kernel/trap.c 


目的： 这是中断和异常的C语言处理总入口。当 kernelvec.S 保存好上下文后，会跳转到这个文件中的C函数（例如 kerneltrap） 。

核心功能：

实现 trap_init() 函数，用于在S模式下设置中断向量表基地址寄存器（stvec），使其指向 kernelvec.S 中的中断入口 。

实现 kerneltrap() 函数 。这个函数是S模式下所有陷阱（trap）的C语言分发中心。

在 kerneltrap() 内部，你需要读取 scause 寄存器来判断陷阱的原因（是异常还是中断？） 。


如果是时钟中断，就调用时钟中断处理函数（timer_interrupt） 。

如果是其他异常（如实验6的系统调用），则进行相应处理 。

kernel/kernelvec.S


参考 xv6 的 kernel/kernelvec.S 


目的： 这是S模式下的中断向量入口。当发生中断或异常时，CPU会跳转到 stvec 寄存器指向的地址，也就是这个文件的入口 。

核心功能：


保存上下文（Context Save）： 立即保存所有通用寄存器（a0-a7, t0-t6等）以及 sepc、sstatus 等CSR寄存器 。通常你会把它们保存在内核栈上（或者像xv6一样保存在一个trapframe结构中）。


调用C处理函数： 保存完上下文后，调用 kernel/trap.c 中的 kerneltrap 函数。

恢复上下文（Context Restore）： 当 kerneltrap 返回后，从栈上恢复所有寄存器。

sret： 执行 sret 指令，从中断返回，继续执行被中断的代码。

kernel/timer.c (推荐)

参考 xv6 的 kernel/timer.c

目的： 专门管理时钟中断。

核心功能：

实现 timer_init()：在 main 函数中调用，用来使能S模式下的时钟中断（通过写 sie 寄存器） 。


实现 timer_interrupt()：这是时钟中断的C语言处理函数 。它会被 kerneltrap 调用。



关键任务： 在 timer_interrupt 中，你需要使用SBI调用（sbi_set_timer）来“预约”下一次时钟中断 。这是实现周期性时钟中断的关键。


（为实验5做准备）在这个函数里，你将来会增加一个计数器（ticks）并触发调度（yield）。

需要修改的现有文件
kernel/boot/start.c

你在这个文件中已经正确地设置了M模式，并将中断/异常委托给了S模式（w_medeleg 和 w_mideleg）。

需要补充： 你还需要在 main 函数（或者在 main 调用的初始化函数中）设置 stvec 寄存器，让它指向你新创建的 kernelvec.S 中的中断入口地址。（勘误：xv6在trap_init中设置w_stvec，这发生在S模式，而不是在start.c的M模式中）。


M模式时钟设置： xv6在 start.c 中还调用了 timerinit() (M-mode) ，它会使能M模式的时钟中断（w_mie）。这样M模式的 timervec 才能收到中断，并通过SBI设置S模式的时钟中断。这是一个比较绕的点，你可以先参考 xv6/kernel/start.c 和 xv6/kernel/timer.c 中的 timerinit 部分。

kernel/main.c

需要补充： 在 main 函数中，kvminithart() 之后，你需要调用你新写的初始化函数，例如：

trap_init() （来自 trap.c）

timer_init() （来自 timer.c）

xv6
自定义 Gem
这是一个非常精准的问题！答案是：不完全是。

硬件自动执行的操作是跳转到 kernelvec.S 的地址，而不是执行 kernelvec.S 本身。

kernelvec.S 是软件代码（汇编指令），而硬件执行的是一组固定的、自动的微操作。

我们来分解一下这个瞬间：

1. 硬件的自动操作
当QEMU模拟的CPU硬件检测到时钟中断信号时，它自动且原子地执行以下硬件操作：


保存PC：将当前正在执行的指令地址（PC）保存到 sepc 寄存器中 。


记录原因：在 scause 寄存器中写入一个代码，表示这是一个“S-Mode时钟中断” 。

保存状态并关闭中断：在 sstatus 寄存器中保存当前的中断使能状态，然后关闭S-Mode的全局中断（SIE位），防止中断嵌套。


读取 stvec 并跳转：这是最关键的一步。硬件会读取 stvec 寄存器（监督模式陷阱向量基址寄存器） 中由xv6内核事先设置好的地址。

强制跳转：硬件强行将PC（程序计数器）设置为从 stvec 读取到的那个地址。



lab 4
----------
本次主要完成S-mode的trap

中断处理过程
硬件检测到中断-保存PC到sepc-写入scause寄存器-sstatus寄存器保存当前中断使能状态，关闭SIE
-跳转到stvec所在的地址-处理中断-返回sepc处地址

scause代码对应trap
代码 8：用户模式环境调用 (即 系统调用) 
代码 12：指令页故障 
代码 13：加载页故障 
代码 15：存储页故障

实验4最重要的代码
// enable the sstc extension (i.e. stimecmp).
  w_menvcfg(r_menvcfg() | (1L << 63)); 