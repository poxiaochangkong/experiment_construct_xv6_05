

实验5

main函数持有锁的时候必须关闭中断，避免数据被中断篡改，同时避免中断处理程序没有持有锁导致程序卡死
需要为printf语句增加一个锁来避免被打断
需要为kalloc.c中的各个函数加锁

scheduler()可直接复制后观察是否可以运行
可运行，在循环中可正常打印信息

时间片约为1s，进程中只有simple_task的情况下可观察到simple_task短时间内大量执行

内存分配目前存在的隐患与解决方案
alloc_page 在内存耗尽时直接 Panic，导致系统崩溃，需要通过异常去解决
procinit 分配的内核栈大小（4KB）可能不够，需要未来考虑动态分配内存
free_page 缺乏双重释放 (Double Free) 检测，增加对freelist的检测即可
kvmmap 的死循环风险，避免溢出的数即可

1. 并发控制与锁 (Concurrency Control)
struct spinlock lock;

作用：这是进程的自旋锁。


为什么要用：正如手册中提到的，多核环境下需要防止竞态条件 。它主要保护进程的状态 (state) 和其他关键属性（如 chan, pid 等），确保在进程状态转换（如从 RUNNABLE 变为 RUNNING）时的原子性。

2. 受锁保护的状态信息 (Protected State)
注意：访问以下字段时，必须持有 p->lock。

enum procstate state;


作用：表示进程当前的生命周期状态 。


取值：包括 UNUSED (未使用), USED (已分配), RUNNABLE (就绪), RUNNING (运行中), SLEEPING (睡眠), ZOMBIE (僵尸) 。调度器 (scheduler) 依据此字段决定是否运行该进程。

void *chan;


作用：等待通道 (Channel) 。

详解：当进程调用 sleep() 进入睡眠状态时，这里会记录它在等待什么（通常是一个内核对象的地址，如锁的地址或管道的地址）。wakeup() 函数会查找所有 chan 匹配的进程并将它们唤醒。

int killed;


作用：被杀标记 。

详解：当其他进程对该进程调用 kill 系统调用时，该值会被置为非零。进程在特定的检查点（如系统调用返回前）会检查此标记，如果为真，则主动退出。

int xstate;


作用：退出状态码 (Exit Status) 。

详解：当进程调用 exit(status) 结束时，status 会保存在这里。父进程调用 wait() 时会读取这个值，从而知道子进程是正常结束还是报错结束。

int pid;


作用：进程 ID 。

详解：这是操作系统唯一标识一个进程的整数编号。

3. 进程层级关系 (Hierarchy)
注意：访问此字段需持有全局的 wait_lock。

struct proc *parent;


作用：指向父进程的指针 。

详解：xv6 维护了父子进程树。当子进程退出变为 ZOMBIE 时，必须由父进程通过 wait() 来回收其资源。如果父进程先退出，子进程会被“过继”给 init 进程。

4. 进程私有资源 (Private Resources)
注意：这些字段通常由进程自己访问，或者在进程未运行时被调度器访问，因此不需要持有 p->lock。

uint64 kstack;


作用：内核栈的虚拟地址 。

详解：当进程从用户态陷入内核态（如系统调用、中断）时，CPU 会切换到这个栈上执行内核代码。每个进程都有自己独立的内核栈。

uint64 sz;


作用：进程用户内存的大小（字节数） 。

详解：标记了用户地址空间的上限。sbrk 系统调用会修改这个值来增长或缩小堆内存。

pagetable_t pagetable;


作用：用户页表 。

详解：这是该进程私有的页表根节点。它定义了进程的虚拟地址如何映射到物理内存。在上下文切换时，内核会将此页表加载到 SATP 寄存器中。

struct trapframe *trapframe;


作用：陷阱帧 。


详解：这是一个非常关键的数据结构，通常映射在虚拟地址 TRAMPOLINE 的正下方。当发生用户态到内核态的切换（Trampoline 跳转）时，用户寄存器的值会被保存在这里；当返回用户态时，从这里恢复寄存器 。

struct context context;


作用：内核调度上下文 。


详解：用于内核线程之间的切换 (swtch 函数) 。它保存了被调用者保存寄存器（如 ra, sp, s0-s11）。注意区分它与 trapframe：trapframe 保存的是用户态的寄存器，context 保存的是内核态调度切换时的寄存器。

5. 文件系统与调试 (File System & Debug)
struct file *ofile[NOFILE];


作用：打开文件表 。

详解：这是一个指针数组。文件描述符 fd 就是这个数组的下标。例如，ofile[1] 指向标准输出的文件结构体。

struct inode *cwd;


作用：当前工作目录 。

详解：指向当前进程所在目录的 inode。解析相对路径（如 ./file）时会用到它。

char name[16];


作用：进程名称 。

详解：主要用于调试。当你按下 Ctrl+P 打印进程列表时，显示的名称就是存在这里的。